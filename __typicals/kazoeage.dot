// https://qiita.com/rubytomato@github/items/51779135bc4b77c8c20d#%E3%82%B0%E3%83%A9%E3%83%95%E3%81%AE%E5%AE%9A%E7%BE%A9
// https://graphviz.org/doc/info/shapes.html

// https://github.com/hamko/procon/blob/master/typical.dot

// cluster から始まる subgraph はハイライトができる

// 新しく追加するノードに関しては問題も添えること

// 問題は record
// で囲む

// red : kazoeage40 で見たけど細分化も例示もできていない
// blue : degwer で見たけど細分化も例示もできていない

digraph G {
    graph [
        layout = fdp;
    ];

    数え上げ [shape = doublecircle, fontsize = 20];

    数え上げ -> グリッド上;
        グリッド上 -> XY座標を独立に考える;
        XY座標を独立に考える -> _45度回転[label="動いて90度回転ロボット"];
        XY座標を独立に考える -> 二項係数の利用[label="ルークの移動"];
            

    数え上げ -> 全探索;

    全探索;
    全探索 -> 何かを固定して考える;
    全探索 -> 何かを固定して数え上げる;
    全探索 -> 半分全列挙;
    全探索 -> 定数倍の削減;
        定数倍の削減 -> 同じことを何回も計算しない;
            y2509[shape = "record", label = "{yukicoder 2509 Beam Shateki|(i, j, dir) で計算すると、\n例えば(0, 0, 3)と(1, 1, 3)は\nほぼ同じものを\nシミュレートしている}"];
            同じことを何回も計算しない -> y2509;
    
    積の法則の利用[color = red];
    二項係数の利用[color = red];
    経路数との対応[color = red];
    
    DP[color = red];

    寄与分の計算[color = red];

    重なりを取り除く[color = red];
    適切な場合分け[color = red];
    条件の言い換え[color = red];
    対称性を用いる[color = red];

    DPの遷移式を変形する[color = red];

    数え上げ -> 積の法則の利用;
    数え上げ -> 二項係数の利用;
    数え上げ -> 経路数との対応;
    数え上げ -> DP;
    数え上げ -> 寄与分の計算;
    数え上げ -> 重なりを取り除く;
    数え上げ -> 適切な場合分け;
    数え上げ -> 条件の言い換え;
    数え上げ -> 対称性を用いる;
    DP -> DPの遷移式を変形する;

    状態をまとめる[color = blue];
    
    数え上げ -> 状態をまとめる [label="単純な全探索アルゴリズムで終端状態まで到達した場合の数が数えたい"];

    探索順の変更[color = blue];
        大きい順に並べる[color = blue];
        順列は挿入DP[color = blue];
        区間は終点でソート[color = blue];

    数え上げ -> 探索順の変更;
        探索順の変更 -> 大きい順に並べる;
        探索順の変更 -> 順列は挿入DP;
        探索順の変更 -> 区間は終点でソート;
    
    条件の言い換え -> DEGWER;
    
    greedyからの帰着[color = blue];

    数え上げ -> greedyからの帰着;

    場合分けのテクニック[color = blue];

    数え上げ -> 場合分けのテクニック;

    線形和への分解[color = blue];

    数え上げ -> 線形和への分解;
    
    部分群のテクニック[color = blue];

    数え上げ -> 部分群のテクニック;

    再帰的な定義の利用[color = blue];

    数え上げ -> 再帰的な定義の利用;

    桁DP[color = blue];

    数え上げ -> 桁DP;

    高速化[color = blue];
        累積和の利用[color = blue];
        データ構造の利用[color = blue];
        配列の使いまわし[color = blue];
        高速フーリエ変換[color = blue];
        高速ゼータ変換[color = blue];
        AndとAddの畳み込み[color = blue];
        簡単な枝刈り[color = blue];

    数え上げ -> 高速化;
        高速化 -> 累積和の利用;
        高速化 -> データ構造の利用;
        高速化 -> 配列の使いまわし;
        高速化 -> 高速フーリエ変換;
        高速化 -> 高速ゼータ変換;
        高速化 -> AndとAddの畳み込み;
        高速化 -> 簡単な枝刈り;
    
    行列を用いたテクニック[color = blue];
        二分累乗[color = blue];
        行列式のテクニック[color = blue];

    数え上げ -> 行列を用いたテクニック;
        行列を用いたテクニック -> 二分累乗;
        行列を用いたテクニック -> 行列式のテクニック;

    小さい確率を無視する[color = blue];

    数え上げ -> 小さい確率を無視する;

    二項係数の利用;
        頻出公式集[color = blue];
        経路数への帰着[color = blue];
        _45度回転[color = blue];
        カタラン数[color = blue];

        二項係数の利用 -> 頻出公式集;
        二項係数の利用 -> 経路数への帰着;
        二項係数の利用 -> _45度回転;
        二項係数の利用 -> カタラン数;

    包除原理[color = blue];
        対称性を用いる場合[color = blue];
        DPを用いる場合[color = blue];
        約数系包除[color = blue];
    数え上げ -> 包除原理;
        包除原理 -> 対称性を用いる場合;
        包除原理 -> DPを用いる場合;
        包除原理 -> 約数系包除;

    解けない問題を見極める[color = blue];
}
